const pattern = /(?:^.*)(<!--([\s\S]*?)-->)(?:.*$)/m

const minZero = ( value ) => Math.max( value, 0 )

let newlineCharacter = '\n'

function getLineCounter ( newline ) {
	return ( string ) => string.split( newline ).length
}

function parseHtmlComments ( input ) {
	const newline = newlineCharacter || '\n'
	if ( typeof input !== 'string' ) {
		throw Error( `Expected argument of type string, received ${typeof input}` )
	}

	const countLines = getLineCounter( newline )
	const numLines = countLines( input )
	const totalChars = input.length

	let cursor = 0

	let remainingText = input
	const matches = []

	while ( cursor < input.length - 1 ) {
		const result = pattern.exec( remainingText )
		if ( !result ) break

		/* Assign the match groups */
		const [ whole, commentOnly ] = result.slice( 0, 2 )

		/* Get columns and set the new cursor position */
		const start = minZero( cursor + result.index )
		const end = start + whole.length
		cursor = end

		/* Slice off match content, for the next loop */
		remainingText = input.slice( end )

		/* Line number values */
		const lineStart = numLines - minZero( countLines( remainingText ) )
		const lineEnd = lineStart + minZero( countLines( whole ) - 1 )

		/* If non-comment text shares space on the start and/or end lines,
		that text is stored. Otherwise, the value is `null` */
		let inline = null
		if ( whole.length > commentOnly.length ) {
			const [ pre, post ] = whole
				.split( commentOnly )
				.map( ( s ) => s.length ? s : null )

			inline = {
				pre,
				post
			}
		}

		matches.push( {
			groups: {
				whole,
				commentOnly,
				lines: {
					whole:       whole.split( newline ),
					commentOnly: commentOnly.split( newline )
				}
			},
			column: { start, end },
			line:   { start: lineStart, end: lineEnd },
			inline
		} )
	}

	return {
		input,
		newLineChar: newline,
		lines:       input.split( newline ),
		lineCount:   numLines,
		charCount:   totalChars,
		matches:     matches
	}
}

parseHtmlComments.newline = newlineCharacter
parseHtmlComments.setNewline = ( sequence ) => {
	if ( typeof sequence !== 'string' ) {
		throw Error( `Expected newline character of type string, received ${typeof sequence}` )
	}
	newlineCharacter = sequence
	parseHtmlComments.newline = newlineCharacter
}

module.exports = parseHtmlComments
module.exports.default = parseHtmlComments
